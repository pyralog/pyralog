graph TB
    subgraph "Six Data Models in Arrow"
        direction LR
        
        RELATIONAL[Relational<br/>SQL tables<br/>Arrow Schema]
        DOCUMENT[Document<br/>JSON/XML<br/>Arrow Struct]
        GRAPH[Property Graph<br/>Cypher<br/>Arrow edges/vertices]
        RDF[RDF Graph<br/>SPARQL<br/>Arrow triples]
        TENSOR[Tensor<br/>N-dimensional<br/>Arrow FixedSizeList]
        KV[Key-Value<br/>Dictionary<br/>Arrow Map]
        
        RELATIONAL -.->|Unified storage| ARROW_STORAGE
        DOCUMENT -.->|Unified storage| ARROW_STORAGE
        GRAPH -.->|Unified storage| ARROW_STORAGE
        RDF -.->|Unified storage| ARROW_STORAGE
        TENSOR -.->|Unified storage| ARROW_STORAGE
        KV -.->|Unified storage| ARROW_STORAGE
    end
    
    subgraph "Arrow Storage Layer"
        direction TB
        
        ARROW_STORAGE[Apache Arrow<br/>Columnar format]
        
        subgraph "Physical Representation"
            ARROW_SCHEMA[Arrow Schema<br/>Type system]
            ARROW_BATCH[RecordBatch<br/>Columnar data]
            ARROW_ARRAY[Array types<br/>Primitive, Struct, List, Map]
        end
        
        ARROW_STORAGE --> ARROW_SCHEMA
        ARROW_STORAGE --> ARROW_BATCH
        ARROW_STORAGE --> ARROW_ARRAY
    end
    
    subgraph "Example: Relational ⇔ Document Join"
        direction TB
        
        subgraph "SQL Table"
            SQL_USERS["users table<br/>id: Int64<br/>name: Utf8<br/>country: Utf8"]
        end
        
        subgraph "JSON Documents"
            JSON_ORDERS["orders collection<br/>id: Int64<br/>user_id: Int64<br/>data: Struct<br/>product, price, qty"]
        end
        
        subgraph "Category Theory Join"
            CT_PULLBACK["Pullback:<br/>users ×_user_id orders"]
            CT_ARROW["Both in Arrow!<br/>Zero-copy join"]
            CT_RESULT["Result:<br/>Unified RecordBatch<br/>user_name, country, order_data"]
        end
        
        SQL_USERS --> CT_PULLBACK
        JSON_ORDERS --> CT_PULLBACK
        CT_PULLBACK --> CT_ARROW
        CT_ARROW --> CT_RESULT
    end
    
    subgraph "Example: Graph ⇔ Relational Join"
        direction TB
        
        subgraph "Property Graph"
            GRAPH_NODES["Nodes: User, Product<br/>Arrow Struct<br/>properties"]
            GRAPH_EDGES["Edges: PURCHASED<br/>Arrow Struct<br/>source, target, properties"]
        end
        
        subgraph "Relational Table"
            REL_INVENTORY["inventory table<br/>product_id: Int64<br/>stock: Int32<br/>warehouse: Utf8"]
        end
        
        subgraph "Cross-Model Query"
            QUERY["Query:<br/>MATCH u:User-PURCHASED->p:Product<br/>JOIN inventory ON p.id = product_id<br/>WHERE stock > 0"]
            OPTIMIZE["DataFusion optimizer<br/>Push filters<br/>Reorder joins"]
            EXECUTE["Execute:<br/>Arrow compute kernels<br/>SIMD vectorized"]
            UNIFIED_RESULT["Unified result:<br/>Arrow RecordBatch"]
        end
        
        GRAPH_NODES --> QUERY
        GRAPH_EDGES --> QUERY
        REL_INVENTORY --> QUERY
        QUERY --> OPTIMIZE
        OPTIMIZE --> EXECUTE
        EXECUTE --> UNIFIED_RESULT
    end
    
    subgraph "Example: Tensor ⇔ Relational Join"
        direction TB
        
        subgraph "Tensor Data"
            TENSOR_EMBEDDINGS["User embeddings<br/>Arrow FixedSizeList<br/>768-dim vectors"]
        end
        
        subgraph "Relational Data"
            REL_USERS["users table<br/>user_id: Int64<br/>segment: Utf8<br/>score: Float64"]
        end
        
        subgraph "ML Feature Join"
            ML_QUERY["Query:<br/>SELECT embedding, segment, score<br/>FROM embeddings<br/>JOIN users ON embedding.user_id = users.id<br/>WHERE segment = premium"]
            ML_ZERO_COPY["Zero-copy:<br/>No deserialize!<br/>Direct array access"]
            ML_TO_PYTORCH["Export to PyTorch<br/>DLPack zero-copy"]
        end
        
        TENSOR_EMBEDDINGS --> ML_QUERY
        REL_USERS --> ML_QUERY
        ML_QUERY --> ML_ZERO_COPY
        ML_ZERO_COPY --> ML_TO_PYTORCH
    end
    
    subgraph "Category Theory Foundation"
        direction TB
        
        subgraph "Schema as Category"
            CT_OBJECTS["Objects:<br/>Data types<br/>Relations, Documents, Graphs"]
            CT_MORPHISMS["Morphisms:<br/>Transformations<br/>Queries, Joins"]
            CT_COMPOSITION["Composition:<br/>Q3 = Q2 ∘ Q1<br/>Associative"]
        end
        
        subgraph "Pullback Semantics"
            CT_PULLBACK_DEF["Pullback:<br/>Universal construction<br/>for joins"]
            CT_COMMUTE["Commutative diagram:<br/>Proven correctness"]
            CT_UNIQUE["Unique morphism:<br/>Deterministic result"]
        end
        
        subgraph "Benefits"
            CT_PROVEN["Proven correct:<br/>Mathematical guarantee"]
            CT_OPTIMIZE["Algebraic laws:<br/>Rewrite rules"]
            CT_TYPE_SAFE["Type-safe:<br/>Compile-time checks"]
        end
        
        CT_OBJECTS --> CT_PULLBACK_DEF
        CT_MORPHISMS --> CT_PULLBACK_DEF
        CT_COMPOSITION --> CT_COMMUTE
        CT_PULLBACK_DEF --> CT_COMMUTE
        CT_COMMUTE --> CT_UNIQUE
        CT_UNIQUE --> CT_PROVEN
        CT_OBJECTS -.->|Enable| CT_OPTIMIZE
        CT_MORPHISMS -.->|Enable| CT_TYPE_SAFE
    end
    
    subgraph "Performance vs Traditional ETL"
        direction TB
        
        subgraph "Traditional Approach"
            ETL_EXTRACT["Extract from DB1<br/>Serialize to JSON"]
            ETL_TRANSFORM["Transform<br/>Deserialize, process"]
            ETL_LOAD["Load to DB2<br/>Serialize again"]
            ETL_QUERY["Query<br/>Finally!"]
            ETL_TIME["Total: 10-50× slower<br/>Multiple copies"]
        end
        
        subgraph "Pyralog Approach"
            PYRA_QUERY["Query across models<br/>Single API"]
            PYRA_ZERO_COPY["Zero-copy:<br/>All data in Arrow"]
            PYRA_RESULT["Results<br/>Instantly"]
            PYRA_TIME["Total: 10-50× faster<br/>No copies!"]
        end
        
        ETL_EXTRACT --> ETL_TRANSFORM
        ETL_TRANSFORM --> ETL_LOAD
        ETL_LOAD --> ETL_QUERY
        ETL_QUERY -.->|Measure| ETL_TIME
        
        PYRA_QUERY --> PYRA_ZERO_COPY
        PYRA_ZERO_COPY --> PYRA_RESULT
        PYRA_RESULT -.->|Measure| PYRA_TIME
    end
    
    subgraph "Example Query: Multi-Model"
        direction TB
        
        QUERY_CODE["graph:match u:User-LIKES->p:Product<br/>&#124; sql:join inventory on p.id = inventory.product_id<br/>&#124; filter inventory.stock > 0<br/>&#124; rdf:match ?p rdf:type schema:Product<br/>&#124; tensor:lookup embedding where user = u.id<br/>&#124; return u.name, p.title, embedding"]
        
        QUERY_COMPILE["Compile to:<br/>DataFusion LogicalPlan<br/>Category-theoretic joins"]
        QUERY_OPTIMIZE["Optimize:<br/>Push filters<br/>Reorder joins<br/>Prune columns"]
        QUERY_EXECUTE["Execute:<br/>Distributed actors<br/>Arrow kernels"]
        QUERY_RESULT["Result:<br/>Unified RecordBatch<br/>All models joined"]
        
        QUERY_CODE --> QUERY_COMPILE
        QUERY_COMPILE --> QUERY_OPTIMIZE
        QUERY_OPTIMIZE --> QUERY_EXECUTE
        QUERY_EXECUTE --> QUERY_RESULT
    end
    
    subgraph "Schema Evolution"
        direction TB
        
        SCHEMA_V1["Schema v1:<br/>users table<br/>id, name"]
        FUNCTOR["Functor:<br/>Add column<br/>email: Utf8"]
        SCHEMA_V2["Schema v2:<br/>users table<br/>id, name, email"]
        NAT_TRANSFORM["Natural transformation:<br/>Migrate data<br/>NULL for missing"]
        SCHEMA_PROVEN["Proven correct:<br/>Category theory<br/>guarantees"]
        
        SCHEMA_V1 --> FUNCTOR
        FUNCTOR --> SCHEMA_V2
        SCHEMA_V2 --> NAT_TRANSFORM
        NAT_TRANSFORM --> SCHEMA_PROVEN
    end
    
    subgraph "Benefits Summary"
        direction LR
        
        BENEFIT_PERF["Performance:<br/>10-50× faster<br/>vs ETL pipelines"]
        BENEFIT_SIMPLE["Simplicity:<br/>Single query API<br/>vs multiple systems"]
        BENEFIT_CORRECT["Correctness:<br/>Category theory<br/>proven joins"]
        BENEFIT_TYPE["Type safety:<br/>Compile-time<br/>schema validation"]
        
        CT_PROVEN -.->|Enable| BENEFIT_CORRECT
        PYRA_ZERO_COPY -.->|Enable| BENEFIT_PERF
        QUERY_CODE -.->|Enable| BENEFIT_SIMPLE
        CT_TYPE_SAFE -.->|Enable| BENEFIT_TYPE
    end
    
    %% Cross-component connections
    ARROW_BATCH -.->|Power| CT_ARROW
    CT_PULLBACK_DEF -.->|Implement| OPTIMIZE
    ARROW_ARRAY -.->|Enable| PYRA_ZERO_COPY
    CT_OBJECTS -.->|Define| ARROW_SCHEMA
    
    %% Styling
    classDef model fill:#9C27B0,stroke:#6A1B9A,color:#fff
    classDef arrow fill:#4A90E2,stroke:#2E5C8A,color:#fff
    classDef join fill:#F57C00,stroke:#E65100,color:#fff
    classDef category fill:#7CB342,stroke:#558B2F,color:#fff
    classDef perf fill:#FFD700,stroke:#FFA000,color:#000
    classDef query fill:#00BCD4,stroke:#0097A7,color:#fff
    
    class RELATIONAL,DOCUMENT,GRAPH,RDF,TENSOR,KV model
    class ARROW_STORAGE,ARROW_SCHEMA,ARROW_BATCH,ARROW_ARRAY arrow
    class SQL_USERS,JSON_ORDERS,CT_PULLBACK,CT_ARROW,CT_RESULT,GRAPH_NODES,GRAPH_EDGES,REL_INVENTORY,QUERY,OPTIMIZE,EXECUTE,UNIFIED_RESULT join
    class CT_OBJECTS,CT_MORPHISMS,CT_COMPOSITION,CT_PULLBACK_DEF,CT_COMMUTE,CT_UNIQUE,CT_PROVEN,CT_OPTIMIZE,CT_TYPE_SAFE,SCHEMA_V1,FUNCTOR,SCHEMA_V2,NAT_TRANSFORM,SCHEMA_PROVEN category
    class ETL_EXTRACT,ETL_TRANSFORM,ETL_LOAD,ETL_QUERY,ETL_TIME,PYRA_QUERY,PYRA_ZERO_COPY,PYRA_RESULT,PYRA_TIME,BENEFIT_PERF,BENEFIT_SIMPLE,BENEFIT_CORRECT,BENEFIT_TYPE perf
    class TENSOR_EMBEDDINGS,REL_USERS,ML_QUERY,ML_ZERO_COPY,ML_TO_PYTORCH,QUERY_CODE,QUERY_COMPILE,QUERY_OPTIMIZE,QUERY_EXECUTE,QUERY_RESULT query

